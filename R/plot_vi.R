#'Plots global importance (i.e. cumulative importance of all features for all response variables) and individual response importance.
#'@param VI A \code{dataframe} dataframe generated from mrvip function 
#'@param X A \code{dataframe} response dataset
#'@param Y A \code{dataframe} feature dataset
#'@param modelPerf A \code{dataframe} dataframe generated by modelPerf function
#'@param cutoff A \code{numeric} determines  mathews correlation coefifcent (mcc) threshold for displaying individual reponse model. Default is 0.5
#'@param mod \code{character}'classification' or 'regression' i.e., is the generative model a regression or classification?
#'@details
#'1st plot: 
#'and individual reponse feature plots (2nd plot). Requires object generated from the R function mrvip as well as feature data (Y).
#'Variables also need to be grouped to allow for easier interpretation. 
#'@example
#'\dontrun{
#'groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#'rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))
#'plot_vi(VI=VI,  X=fData,Y=FeaturesnoNA, modelPerf=ModelPerf, groupCov, cutoff= 0.5)}
#'@export 

plot_vi <- function (VI, modelPerf, Y, X, groupCov=NULL, cutoff= 0.2, plot.pca='no', model='regression' ){

  #colnames(VI) <- names(X)
  row.names(VI) <- names(X)
  #n_features <- sort(names(Y))
  n_features <-  names(VI)
  VIa <-  as.data.frame(t(VI))
  #----------------------------------------------------------------
  #Global importance
  #----------------------------------------------------------------

  #for interpretation of group features.
  
    rs <- as.data.frame( rowSums(VIa)/sum(VIa) ) #make it a proportion
      rsA <- rownames_to_column(rs)
      
  if (!is.null(groupCov)) { 
    
   
    rsA <- cbind(rsA, groupCov) # attach group info
  names(rsA)[2] <- c('prop')
    rsA$row <- 1 #dummy x axis
    
    
   p1 <-  ggplot(rsA, aes(fill= groupCov, y=prop, x= row)) + 
         theme_bw()+
         labs(y= "Cumulative importance")+
          geom_bar(position="stack", stat="identity") +
          scale_fill_viridis(discrete = T)+
          theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank())+
          labs(fill='Feature') 
   print(p1)
   readline(prompt="Press [enter] to continue for the top individual models")
   
    #----------------------------------------------------------------
    #Individual response importance
    #----------------------------------------------------------------
  
  trans <- as.data.frame(VI)
  features <-  colnames(trans) 

  combi <- bind_cols(ModelPerf[1], trans ) %>% 
  na.omit() #nas mean the model didn't work properly remove. Should provide a warning perhaps?

  if (model=='classification'){
    
  combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again.
  combiF <- filter(combi, mcc > cutoff) 
  # poorly performing models don't get included. COuld make this user defined. Need a warning here
  combiF$response <- as.character(combiF$response) 
  
  combiF$model_name <- NULL #don't need these columns anymore. May be nice to print them on plot?
  combiF$mcc <- NULL
  combiF$sensitivity <- NULL
  combiF$specificity <- NULL
  combiF$roc_AUC <- NULL
  combiF$prevalence <- NULL
  
  }
  if (model=='regression'){
    
    combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
    combiF <- filter(combi, rsquared > cutoff)  
    combiF$response <- as.character(combiF$response) 
    
    combiF$rmse <- NULL #don't need these columns anymore. May be nice to print them on plot?
    combiF$rsquared <- NULL
    combiF$model_name <- NULL 
    
  }
    combiFT <- as.data.frame(t(combiF)) %>%  row_to_names(row_number = 1)

  #------------------------------------------------------------------  
  
  data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot

  charvec <- rep(n_features, length(combiFT)) #create a vector of feature names

  charvecGroup <- rep(groupCov, length(combiFT)) #make it easier to read 

  finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
  finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
  
  finaldf$importance <- as.numeric(finaldf$importance) 
  finaldfg$importance <- as.numeric(finaldfg$importance)

  #not the biggest fan of barplots  - but they are the easiest to see in this case.
  
  p2 <- ggplot(finaldfg, aes(fill=charvecGroup  , y=importance, x=charvecGroup )) + 
    geom_bar(position="dodge", stat="identity") +
    scale_fill_viridis(discrete = T, option = "E") +
    ggtitle("Individual response models") +
    facet_wrap(~response) +
    theme_ipsum() +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
  labs(fill='Feature set') #could be a nice extension to add mcc/spec/sens to the model
#theme(legend.position="none") + #I like the legend personally rather than lots of x axis text.
  
readline(prompt="Press [enter] to plot individual variable importance summaries")  
  print(p2)
  }
    
    
#-----------------------------------------------------------------------------------------------------------  
  if (is.null(groupCov)) {
    
#FeatureName <- as.data.frame(names(Y))   #this is more flexible
         # FNameOrdered <- FeatureName[order(FeatureName$'names(Y)'),]
    
    #rsA <- cbind(rsA, n ) # add featue names back
    
    names(rsA)[2] <- c('prop')
    rsA$row <- 1 #dummy x axis
    
    
    p1 <-  ggplot(rsA, aes(y=reorder(rowname, prop), x= prop)) + 
      geom_bar(stat="identity")+
      theme_bw()+
      labs(y= "Feature", x='Cumulative importance')
    print(p1)
    
    readline(prompt="Press [enter] to plot individual variable importance summaries") 
#----------------------------------------------------------------
    #Individual response importance
#----------------------------------------------------------------
    
    trans <- as.data.frame(VI)
   # colnames(trans) <- n_features
    
    combi <- bind_cols(ModelPerf[1], trans ) 
      combi[is.na(combi)] <- -1 #nas mean the model didn't work properly remove. Should provide a warning perhaps?
    
    if (model=='classification'){
      
      combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again.
      combiF <- filter(combi, mcc > cutoff) 
      # poorly performing models don't get included. COuld make this user defined. Need a warning here
      combiF$response <- as.character(combiF$response) 
      
      combiF$model_name <- NULL #don't need these columns anymore. May be nice to print them on plot?
      combiF$mcc <- NULL
      combiF$sensitivity <- NULL
      combiF$specificity <- NULL
      combiF$roc_AUC <- NULL
      combiF$prevalence <- NULL
      
    }
    if (model=='regression'){
    
      
      combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
      combiF <- filter(combi, rsquared > cutoff)  
      combiF$response <- as.character(combiF$response) 
      
      combiF$rmse <- NULL #don't need these columns anymore. May be nice to print them on plot?
      combiF$rsquared <- NULL
      combiF$model_name <- NULL 
      
      
    }
    
    combiFT <- as.data.frame(t(combiF)) %>%  row_to_names(row_number = 1) 
    
      #------------------------------------------------------------------  
      
      data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot
      
      charvec <- rep(n_features, length(combiFT)) #create a vector of feature names
      
      #charvecGroup <- rep(groupCov, length(combiFT)) #make it easier to read 
      
      finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
      #finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
      
      finaldf$importance <- as.numeric(finaldf$importance) 
     # finaldfg$importance <- as.numeric(finaldfg$importance)
      
      #not the biggest fan of barplots  - but they are the easiest to see in this case.
      
      p2 <- ggplot(finaldf, aes(fill=charvec  , y=importance, x=charvec )) + 
        geom_bar(position="dodge", stat="identity") +
        scale_fill_viridis(discrete = T, option = "E") +
        ggtitle("Individual response models") +
        facet_wrap(~response) +
        theme_ipsum() +
        theme(axis.title.x=element_blank(),
              axis.text.x=element_blank(),
              axis.ticks.x=element_blank())+
        labs(fill='Feature set') #could be a nice extension to add mcc/spec/sens to the model
      #theme(legend.position="none") + #I like the legend personally rather than lots of x axis text.
      
      print(p2)
    }
      #------------------------------------------------------------------  
      #Importance PCA plot. Responses with similar importance scores group together
      #------------------------------------------------------------------    
      
      
      if (plot.pca=='yes'){ # impossible to read with many responses
        
        readline(prompt="Press [enter] to plot the importance PCA plot")  
        
        # a1 <- a[,-1] %>%  mutate_if( is.factor, ~ as.numeric(as.character(.x))) #this is a handy function
        #row.names(a1) <- a$rowname
        #trans <- as.data.frame(t(VI) )
        
        a.pca <- rda(trans) #this includes all respoinses
        
        uscores <- data.frame(a.pca$CA$u)
       # uscores <- data.frame(test$CA$u)
        
        p3 <- ggplot(uscores  , aes(x = PC1, y = PC2)) + 
          geom_point() + 
          geom_label_repel(aes(label = rownames(trans)),
                           box.padding   = 0.35, 
                           point.padding = 0.5,
                           label.size = 0.1,
                           segment.color = 'grey50') +
          theme_bw()
        #  geom_text(data = vscores, aes(x = PC1, y = PC2, label = rownames(vscores)), col = 'red')
        # geom_text(data = vscores, aes(x = PC1, y = PC2, label = rownames(vscores)), col = 'red')
        print(p3)
      }
      #for 3D plots that are interactive.
       #adapt <- c(rep('diag', 2), rep('gradient', 2), rep('habitat', 2), rep('neutral', 94) )
      #uscores <- as.data.frame(cbind(uscores,adapt))
      # p4 <- plotly::plot_ly(uscores, x=~PC1, y=~PC2, z=~PC3, color = ~adapt, colors = c('#BF382A', '#0C4B8E', '#1DF20D','#B9B930' )) %>% 
        # plotly::add_markers()
   
       if(plot.pca=='no'){plotpc=0}
      }
